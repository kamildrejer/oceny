# -*- coding: utf-8 -*-
"""


konwersja układu dla plików projektowych

/***************************************************************************
 Oceny
                                 A QGIS plugin
 Narzędzie do wykonywania ocen oddziaływania inwestycji na przyrodę.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-04-16
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Kamil Drejer
        email                : klamot@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from PyQt5 import QtCore, QtGui, QtWidgets #works for pyqt5
from qgis.gui import QgsFileWidget

from qgis.core import QgsVectorLayerJoinInfo
from qgis.core import QgsProject
from qgis.core import QgsField
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsVectorLayer#, QgsDataSourceUri
from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsCoordinateTransformContext
from qgis.core import QgsVectorFileWriter
from qgis.core import Qgis, QgsSpatialIndex
from qgis.core import (
  QgsGeometry, QgsGeometryCollection,
  QgsPoint,
  QgsPolygon,
  QgsField,
  QgsFields,
  QgsMultiPoint,
  QgsFeature,
  QgsPointXY,
  QgsWkbTypes,
  QgsProject,
  QgsFeatureRequest,
  QgsVectorLayer,
  QgsDistanceArea,
  QgsUnitTypes,
)
from qgis.core import QgsMapLayerProxyModel
from qgis.utils import iface


from PyQt5.QtWidgets import *
from PyQt5 import (QtCore, QtGui)
from PyQt5.QtGui import *
from PyQt5.QtCore import *

# from PyQt5.QtCore import QVariant

import processing
import re, ntpath, math, shutil
from .chainagetool import points_along_line

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .oceny_dialog import OcenyDialog
import os.path, os
from  .oceny_core import *


class Oceny:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Oceny_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Oceny')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Oceny', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        icon_path = ':/plugins/oceny/icon.png'
        self.iconAction = self.add_action(
            icon_path,
            text=self.tr(u'Oceny'),

            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'Oceny'),
                action)
            self.iface.removeToolBarIcon(action)

    def mkdir_and_remove(self, path, name):
        path_zlaczone = os.path.join(path, name)
        if os.path.exists(path_zlaczone) and os.path.isdir(path_zlaczone):
            try:
                shutil.rmtree(path_zlaczone, ignore_errors = False)
                os.mkdir(path_zlaczone)
                return False
            except:
                self.error_status(7)
                return True
        else:
            try:
                os.mkdir(path_zlaczone)
                return False
            except:
                self.error_status(6)
                return True
        return False

    def error_status(self, code):
        self.code = code
        if code == 1:
            iface.messageBar().pushMessage("Ojej! ", "warstwa "+str(layer.name())+" ma jakiś obiekt bez geometrii. Spróbuj to naprawić albo wykonać analizę bez tej warstwy", level=Qgis.Critical)
            self.dlg.reject()
        elif code == 2:
            iface.messageBar().pushMessage("Ojej! ", "nie znaleziono żadnej poprawnej warstwy lub warstwy są puste", level=Qgis.Critical)
            self.dlg.reject()
        elif code == 3:
            iface.messageBar().pushMessage("Ojej! W osi występuje obiekt z pustą geometrią", level=Qgis.Critical)
            self.dlg.reject()
        elif code == 4:
            iface.messageBar().pushMessage("Ojej! W warstwie przecinanej występuje obiekt z pustą geometrią", level=Qgis.Critical)
            self.dlg.reject()
        elif code == 5:
            iface.messageBar().pushMessage("Ojej! Wybierz folder wyjściowy lub warstwę wirtualną jeśli jest dostępna", level=Qgis.Critical)
            self.dlg.reject()
        elif code == 6:
            iface.messageBar().pushMessage("Ojej! Nie znaleziono folderu wyjściowego", level=Qgis.Critical)
            self.dlg.reject()
        elif code == 7:
            iface.messageBar().pushMessage("Ojej! W folderze wyjściowym są pliki, których nie mozna skasować. Usuń te pliki lub zmień folder", level=Qgis.Critical)
            self.dlg.reject()
        return self.code

    def makepath_gpkg(self, root_dir, file, layer, inout):
        if len(root_dir) == 0:
            root_dir = self.root_dir

        path_to_file = os.path.join(root_dir, file)
        if inout == 'in':
            result =  '{}|layername={}'.format(path_to_file, layer ) #'ogr:dbname=\'{}\' table="{}" (geom)'.format(path_to_file, layer ) #
        else:
            result =  'ogr:dbname=\'{}\' table="{}" (geom)'.format(path_to_file, layer ) #
        
        return result


    def run(self):
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = OcenyDialog()

        self.dlg.obszar.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.os.setFilters(QgsMapLayerProxyModel.LineLayer)
        self.dlg.km.setFilters(QgsMapLayerProxyModel.PointLayer)

        #do aktualizacji pola z kilometrazem
        self.dlg.mFieldComboBox.setLayer(self.dlg.km.currentLayer())

        self.dlg.groupBox_2_km.isChecked()
        self.dlg.groupBox_2_os.isChecked()
        self.dlg.groupBox_2_pas.isChecked()

        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed

        # print(result)
        if result==1:
            error = False

            warstwy = LoadLayers()
            layers_teren = []
            if self.dlg.groupBox_3.isChecked():
                
                layers_teren.append(self.makepath_gpkg('G:\\Dyski współdzielone\\1_Public\\QGiS\DANE\\03_BDOT10k', 'warstwyBDOT10k.gpkg', 'A_PTLZ', 'in'))

                warstwy.loadLayersFromStringList(layers_teren)
                print(layers_teren)

            else:
                #sprawdź czy zaznaczno opcję wyboru całego folderu
                if not self.dlg.checkFolder.isChecked():
                    #jeżeli nie cały folder, dodaj do listy warstw warstwę z pola wyboru
                    warstwy.loadLayer(self.dlg.layer_proj.currentLayer(),'')
                else:
                    #jeśli tak, dodaj pliki z listy do listy layers_temp
                    warstwy.loadLayersFromStringList(QgsFileWidget.splitFilePaths(self.dlg.pliki_list.filePath()))

            #sprawdź poprawność warstw
            if self.error_status(warstwy.checkLayerValidity()) != 0:
                return

            os_inst  = LoadLayers() #nowa instancja obiektu
            km_inst = LoadLayers() #nowa instancja obiektu
            obszar_inst = LoadLayers() #nowa instancja obiektu

            if not self.dlg.checkFolder_2.isChecked():
                #jeżeli nie cały folder, dodaj do listy warstw warstwę z pola wyboru
                #wczytanie warstw z projektem
                os_inst.loadLayer(self.dlg.os.currentLayer(), 'wyniki_') #załadowanie warstwy
                km_inst.loadLayer(self.dlg.km.currentLayer(), 'wyniki_') #załadowanie warstwy
                obszar_inst.loadLayer(self.dlg.obszar.currentLayer(), 'wyniki_') #załadowanie warstwy

                km_checked = self.dlg.checkBox_km.isChecked()
                os_checked = self.dlg.checkBox_os.isChecked()
                pas_checked = self.dlg.checkBox_pas.isChecked()
                prefixes = {'wyniki_'}

            else:
                #jeśli tak, dodaj pliki z listy do listy layers_temp
                os_inst.loadLayersFromStringList(QgsFileWidget.splitFilePaths(self.dlg.pliki_list_os.filePath()))
                km_inst.loadLayersFromStringList(QgsFileWidget.splitFilePaths(self.dlg.pliki_list_km.filePath()))
                obszar_inst.loadLayersFromStringList(QgsFileWidget.splitFilePaths(self.dlg.pliki_list_pas.filePath()))

                km_checked = self.dlg.groupBox_2_km.isChecked()
                os_checked = self.dlg.groupBox_2_os.isChecked()
                pas_checked = self.dlg.groupBox_2_pas.isChecked()
                prefixes = os_inst.getPrefixes()

            # Parent Directory path
            parent_dir = self.dlg.output_path.filePath()
            if parent_dir is None and (not self.dlg.output_virt.isChecked()):
                self.error_status(5)

            # if pas_checked and (not self.dlg.output_virt.isChecked()):
            #     error_status(5)

            if self.dlg.checkFolder_2.isChecked():
                error = error| self.mkdir_and_remove(parent_dir, 'zlaczone')

            #sprawdź poprawność warstw
            if os_checked and self.error_status(os_inst.checkLayerValidity()) != 0:
                error = True
                return

            if km_checked and self.error_status(km_inst.checkLayerValidity()) != 0:
                error = True
                return

            if pas_checked and self.error_status(obszar_inst.checkLayerValidity()) != 0:
                error = True
                return

            os_inst.makeNewLayers()
            km_inst.makeNewLayers()
            obszar_inst.makeNewLayers()

            crs92 = "EPSG:2180"

            warstwy.makeNewLayers()
            warstwy.addFields(km_checked, os_checked, pas_checked)

            licz_warstwy_inwestycyjne = 0
            suma_warstw_inwestycyjnych = 0

            if (km_checked):
                licz_warstwy_inwestycyjne +=1
                suma_warstw_inwestycyjnych += len(km_inst.getLayers())
            if (os_checked):
                licz_warstwy_inwestycyjne +=1
                suma_warstw_inwestycyjnych += len(os_inst.getLayers())
            if (pas_checked):
                licz_warstwy_inwestycyjne +=1
                suma_warstw_inwestycyjnych += len(obszar_inst.getLayers())

            # len(os_inst.getLayers()) == len(km_inst.getLayers()) and len(os_inst.getLayers()) == len(obszar_inst.getLayers())

            if not (suma_warstw_inwestycyjnych%licz_warstwy_inwestycyjne == 0):
                iface.messageBar().pushMessage("Ojej! Różna liczba warstw projektowych", level=Qgis.Critical)
                error = True

            km_pref = set()
            for item in km_inst.getPrefixes():
                km_pref.add(item)
            os_pref = set()
            for item in km_inst.getPrefixes():
                os_pref.add(item)
            pas_pref = set()
            for item in km_inst.getPrefixes():
                pas_pref.add(item)

            if not (km_pref == os_pref and os_pref == pas_pref):
                iface.messageBar().pushMessage("Ojej! Różne prefixy", level=Qgis.Critical)
                error = True

            wariant = 0
            paths_to_merge = {}
            for prefix in prefixes:
                # Path
                print(prefix)
                directory = re.sub('_', '', prefix)
                error = error|self.mkdir_and_remove(parent_dir, directory)

            if (not error):
                for prefix in prefixes:

                    paths_to_merge[prefix] = []
                    # Directory
                    directory = re.sub('_', '', prefix)
                    path = os.path.join(parent_dir, directory)

                    km_inst_by_prefix = km_inst.getLayersByPrefix(prefix)
                    os_inst_by_prefix = os_inst.getLayersByPrefix(prefix)
                    obszar_inst_by_prefix = obszar_inst.getLayersByPrefix(prefix)

                    #Twórz indeks przestrzenny dla warstwy z kilometrażem
                    if self.dlg.checkBox_km.isChecked():
                        print(km_inst_by_prefix)
                        print(prefix)
                        spIndex = km_inst_by_prefix.makeSpatialIndex()

                    #Pętla po każdej warstwie
                    for layer_orygin_klasa in warstwy.newLayers(): #przejdź przez każdą klasę Layer w zbiorze newLauers (z dodanymi polami)
                        polygon = layer_orygin_klasa.czyPolygon() # ustal czy warstwa poligonowa

                        #Obliczanie dystansu od osi i strony
                        if self.dlg.checkBox_km.isChecked() and self.dlg.checkBox_os.isChecked():
                            if self.error_status(layer_orygin_klasa.distansStrona(os_inst_by_prefix)) != 0:
                                return

                        #Obliczanie kilometraży i pow przeciec
                        kmfield = 1
                        if not self.dlg.checkFolder_2.isChecked():
                            kmfield = self.dlg.mFieldComboBox.fields().indexFromName(self.dlg.mFieldComboBox.currentField())
                        layer_orygin_klasa.przeciecia(km_inst_by_prefix, os_inst_by_prefix, obszar_inst_by_prefix, km_checked, os_checked, pas_checked, kmfield)

                        layer_orygin = layer_orygin_klasa.getLayer()
                        crs_system92 = QgsCoordinateReferenceSystem(crs92)
                        root = QgsProject.instance().layerTreeRoot()
                        destination = path +'\\'+layer_orygin.name() #'C:\temp\a.shp'

                        if self.dlg.output_virt.isChecked():
                            root.addLayer(layer_orygin)
                            QgsProject.instance().addMapLayer(layer_orygin, False)
                        else:
                            error = QgsVectorFileWriter.writeAsVectorFormat(layer_orygin, destination, "UTF-8", crs_system92 , "ESRI Shapefile")

                            if destination[-3:]!='shp':
                                destination_shp = destination + '.shp'
                            else:
                                destination_shp = destination
                            layer_out_res = QgsVectorLayer(destination_shp, layer_orygin.name(), "ogr")
                            layer_orygin_klasa.addResultPathAndPrefix(destination_shp, prefix)

                            if not self.dlg.checkFolder_2.isChecked() or (self.dlg.checkFolder_2.isChecked() and self.dlg.add_wariant_layer.isChecked()):
                                QgsProject.instance().addMapLayer(layer_out_res, False)
                                root.addLayer(layer_out_res)

                iface.messageBar().pushMessage("Sukces! ", "Przerobiono "+ str(warstwy.licznik_warstw) +" warstw", level=Qgis.Success)
                if self.dlg.checkFolder_2.isChecked():
                    for layer_klasa in warstwy.newLayers():
                        path_zlaczone = os.path.join(parent_dir, 'zlaczone')
                        output = os.path.join(path_zlaczone, layer_klasa.getLayer().name())  #+'\\zlaczone\\'+layer_orygin.name()
                        if output[-3:]!='shp':
                            output_shp = output + '.shp'
                        else:
                            output_shp = output

                        layer_paths_and_prefix = layer_klasa.getResultPathsAndPrefix()
                        print(layer_paths_and_prefix)
                        zlacz_warianty = ZlaczWarianty(layer_paths_and_prefix)

                        warstwy_zlaczone = zlacz_warianty.mergeLayers(output_shp)

                        name = os.path.basename(warstwy_zlaczone)
                        warstwa = QgsVectorLayer(warstwy_zlaczone, str('ZL_' + name), "ogr")
                        root.addLayer(warstwa)
                        QgsProject.instance().addMapLayer(warstwa, False)

                #zmienna warianty - brać wariant inwestycji odpowiedni, teraz zmienna warianty sięnie zmieni i = 0
